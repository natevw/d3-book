<!doctype html>
<html><head>
    <meta charset="utf-8">
    <title>Chapter sample</title>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <style>
      body { max-width: 50em; }
      svg.example.output {
        display: block; background: #FBFBFB;
        margin: 2em 4em; padding: 1em;
        max-width: 20em;
        max-height: 20em;
      }
      code.example {
        display: block; background: #DDD;
        margin: 2em 5em; padding: 1em;
        white-space: pre;
        overflow: auto;
      }
    </style>
</head><body>

<h1>D3.js in Awesome</h1>

<h2>What is D3.js?</h2>
<h2>Showing data using SVG</h2>

(Finish with chart referenced in animation chapter)
<svg class="example output"></svg>
<script type="x-book/x-sample">
var layout = d3.layout.pie().sort(null).value(function (d) { return d.amount; }),
    generator = d3.svg.arc().outerRadius(10),
    scale = d3.scale.category10();

// TODO: add labels, c.f. http://bl.ocks.org/enjalot/1203641

d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout)
  .enter().append('svg:path').attr('d', generator).attr('fill', function (d,i) { return scale(i); });
</script>


<!-- TYPING -->

<h2>Animated transitions</h2>

We've turned all sorts of data into all sorts of charts.

These charts communicate well and look great, but are probably out of date within a few trillion CPU cyclesâ€¦that's what, ten minutes in human years? The message you need convey may be constantly changing. Otherwise, if the underlying *data* doesn't change, why not let viewers change how it's *presented* to better understand the information?

<h3>Letting charts get lively</h3>

In the next chapter we'll see how to add this user interaction, and in Chapter 6 we'll look at various ways your code can best manage the changing state of the data it's displaying. For now, let's continue focusing on what the viewer sees, the visible results.

Remember how we said D3.js makes it easy not just to create a data display, but to update an existing document with changed data? Let's take our pie chart from the last chapter. We've wrapped all the drawing code in a function, but it's otherwise identical:

<svg class="example output"></svg>
<script type="x-book/x-sample">
function drawChart() {
  var layout = d3.layout.pie().sort(null).value(function (d) { return d.amount; }),
      generator = d3.svg.arc().outerRadius(10),
      scale = d3.scale.category10();
  
  d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout)
    .enter().append('svg:path').attr('d', generator).attr('fill', function (d,i) { return scale(i); });  
}
drawChart.call(this);
</script>

For each sample data item, we simply append the SVG element which will represent it visually and set its properties accordingly. This doesn't support changing the visual representation when the data changes. If we change the data and run this code again, what will happen? D3 will join the changed data with the result of <code>.selectAll('path')</code>, which we said in Chapter 1 involves dividing the selection into its three sets: the entering set (missing elements), the updating set (elements already present), and exiting set (extra elements).

If we only handle the entering part of our selection, new elements will display as intended the first time but then will never change! This code will only work with *additional* data, not with revised or removed data. Let's fix that.

<h3>Same old operators, brand new data</h3>

Here's how we need to write our <code>drawChart()</code> function to work properly when called multiple times, regardless of how the data changes in between calls:

<svg class="example output"></svg>
<script type="x-book/x-sample">
function drawChart() {
  var layout = d3.layout.pie().sort(null).value(function (d) { return d.amount; }),
      generator = d3.svg.arc().outerRadius(10),
      scale = d3.scale.category10();
  
  var boundSelection = d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout);
  boundSelection.enter().append('svg:path');
  // what we append/insert/select in the entering selection gets added to the main (updating) selection (from v2.0)
  boundSelection.attr('d', generator).attr('fill', function (d,i) { return scale(i); });
  boundSelection.exit().remove();
}

// generate the "original" DOM
drawChart.call(this);

// modify the data
timeUse[0].amount /= 2;
timeUse.push({
  activity: "Gathering lumber",
  amount: timeUse[0].amount
});

// now call it again, to update the DOM
drawChart.call(this);
</script>

Here's what we did:

<ul>
<li>move the data-dependent operations from the enter to the updating selection</li>
<li>handle any data removal that might occur via the exiting selection</li>
</ul>

But it blinks!


<h3>Object persistence with relational joins</h3>
<h3>How relational joins work</h3>
<h3>Transition tips and tricks</h3>
<h3>Using CSS3/SVG alternatives to .transition()</h3>


<!-- /TYPING -->


<h2>Interactive data displays</h2>


<script>

DATA = {};

DATA.timeUse = [
  {activity:"Field work", amount:50},
  {activity:"Choring animals", amount: 10},
  {activity:"Meal time", amount: 8},
  {activity:"Playing fiddle", amount: 2},
  {activity:"Resting", amount:30}
];

</script>
<script>
d3.selectAll('script[type="x-book/x-sample"]').select(function () {
  // run the sample to show the result (within the node immediately preceding it)
  try {
    eval("(function ("+d3.keys(DATA).join(',')+") {" + this.textContent + "})")
      .apply(this.previousElementSibling, d3.values(DATA));
  } catch (e) { console.warn(e); }
  
  // display the code within a visible block
  var el = document.createElement('code');
  el.textContent = this.textContent.trim();
  this.parentNode.replaceChild(el, this)
  return el;
}).classed('example', true);
</script>
</body></html>

