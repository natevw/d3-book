<!doctype html>
<html><head>
    <meta charset="utf-8">
    <title>Chapter sample</title>
    <script src="d3.v3.min.js"></script>
    <style>
      body { max-width: 50em; }
      svg.example.output {
        display: block; background: #FBFBFB;
        margin: 2em 4em; padding: 1em;
        max-width: 20em;
        max-height: 20em;
      }
      code.example {
        display: block; background: #DDD;
        margin: 2em 5em; padding: 1em;
        white-space: pre;
        overflow: auto;
      }
      dt { display: inline-block; margin-right: 1ex; font-weight: bold; }
      dd { margin: 0; }
      tr.remove { color: lightgrey; }
    </style>
</head><body>

<h1>D3.js: the book</h1>

<h2>What is D3.js?</h2>

<i>There are only two hard things in Computer Science: cache invalidation and naming things.</i> <!-- Phil Karlton http://martinfowler.com/bliki/TwoHardThings.html -->

<p>
At its core, D3.js solves a fundamental problem (perhaps <em>the</em> fundamental problem) of software architecture: synchronizing state between two components of an application — dissimilar components at that. There is an impedance mismatch between JavaScript code and rendered HTML which D3 deftly bridges with only a few short spans.

<p>
But I digress.

<p>
D3 stands for "<b>D</b>ata-<b>D</b>riven <b>D</b>ocuments", which is an alliterative way of saying that D3.js is a JavaScript library intended for using web pages to show information. It is also an <em>action</em>-filled way to say what we will soon see for ourselves: it's the information, the data, which is emphasized as doing the work. The data ends up driving the visualization.

<p>
D3 is different. It's a visualization library with no "chart" base class which, once instantiated, would insulate you from having to manipulate the DOM. It's a DOM manipulation library, but with no shorthand for something as useful as toggling an element's style to an opposite state. It's built around a very terse toolkit, one which shows great parsimony in the grammar used to customize its results, yet it allows an infinite variety of graphs, charts, and even entire "apps" to be maintained.

<p>
There are really only two core interactions that make this all work: <i>bound selections</i> and a few basic code-controlled <i>operators</i> applied upon them. These are the matter and <!-- potential --> energy, respectively, of D3's universe. Or, to use an even better analogy from a slightly higher realm, they are the raw amino acids <em>plus</em> the DNA which together can form proteins, which can then build cells, which may form entire systems and ecosystems. Biology has discovered that only six major chemical elements (and little doses of a dozen or so micronutrients) compose any living thing — from a prokaryote to a plant to a person. <!-- http://en.wikipedia.org/wiki/Biochemistry#Starting_materials:_the_chemical_elements_of_life --> Similarly, there are only a few core methods for working with D3 selections, but the different designs recorded in our operator logic will flower into a myriad of results.

<p>
At first, unfortunately, the task of designing a complex visualization using only a few simple constructs can be daunting. Don't worry — this feeling will pass.

<p>
Soon enough, feeling overwhelmed will be replaced with <em>seeing</em> powerfully: first seeing the underlying data, then seeing the hidden logic that transformed it into a visualization, and always seeing the same patterns, reused and remixed and even repurposed. It <em>is</em> resuable patterns that D3 provides, just not usually at the "chart" level. D3 captures patterns which can be reused for <em>anything</em> — not just stamping out some same old graph with only different data. D3's patterns are naturally reusable for totally new types of visualization and interaction! D3 handles maps and apps as well as it handles interactive charts — and it does handle the latter very well.

<p>
Look at this:

<div>[three ways of seeing the same data]</div>
<script type="x-book/x-sample">
var majorElements = ["carbon", "hydrogen", "nitrogen", "oxygen", "calcium", "phosphorus"];

// list
// horizontal bars (character length)
// labeled vertical bars
</script>

<p>
… discussion of each …

<p>
If we had more useful data — if for every chemical element we also had recorded its unique number of protons — we could perform more useful variations on the visualization. We could sort by this more meaningful number, or even arrange the elements not only in correct order but also so the visual distance between each was proportional to the difference in atomic number.

<p>
By learning to see the patterns, the similarities between how <em>every</em> visualization is made, you will also begin to quickly understand the <em>differences</em> as well.

<p>
What has changed?

<div>[each display above, but now sorted alphabetically]</div>
<script type="x-book/x-sample">
// ± repeat above but with sorting added
</script>

<p>
… discussion of sorting …

<p>
This book is not a recipe book — there are too many delicious dishes to enumerate, and even more that should be invented.
D3.js [needs your help filling "custom logic" holes, but is more of a grammar needing borrowed adverbs than a fill-in-the-blank template]

<p>
Instead this book is about:
[
<li>showing how things really work in the small
<li>showing how these pieces are usually fit together as a whole
]


<h3>Combining documents and data</h3>
…
 


<h3>Selecting past, present and future elements</h3>
…

<h3>If I didn’t have you: displaying data the hard way</h3>
…

<h3>Operating on selections</h3>
…

<h3>How data bindings work</h3>
…

<h3>Updating when data changes</h3>
…

<h2>Showing data using SVG</h2>

<!--
<i>"Smoking is one of the leading causes of statistics."</i> <!-- http://en.wikipedia.org/w/index.php?title=Fletcher_Knebel&oldid=555451790 via: Fletcher Knebel, who keenly observed as far back as 1961 that "smoking is the leading cause of statistics" - http://www.salon.com/people/feature/2000/02/09/sevenvices/ -->

<!--
<i>He said they spoke all languages and were very clear and easily understood.</i> <!-- William Playfair, "in his unpublished memoirs" via http://www.psych.utoronto.ca/users/spence/Spence_Wainer_1997b.pdf -->

<i>No ſort of reflection is however meant on thoſe who think fit to give their ſtatements in the other way, although the number of figures certainly embarraſſes the memory without anſwering any good purpoſe.</i> <!-- William Playfair, The Statistical Breviary (1801) -->

<!--
<i>That tear, good girl, is worth, ten thousand words.</i> <!-- Charles Breck in The Trust (1802) via http://www.phrases.org.uk/meanings/a-picture-is-worth-a-thousand-words.html -->

<p>
[TBD: chapter outline]

<p>
We've seen that D3 makes it easy to manipulate elements within document's object model to make them match data input, and we've said that D3's core patterns are applicable to a wide range of uses. It's time we proved that.

<p>
It's also time to tackle what D3 is most famous for: graphs and charts!

<p>
Surprisingly, statistical graphics are barely older than a few centuries. Like our recent decade's acceptance of using a computer's Graphics Processing Unit for calculations that have little to do with displaying shaded surfaces on a monitor, pictures and diagrams (which had long been used to communicate more obviously "graphical" information like mugshots and maps and math) suddenly became an option for <em>general purpose</em> information presentation.

<p>
[TBD: table vs graph demo(s)]

<p>
Showing data as pictures engages the human <em>visual</em> system's power for more abstract purposes. Instead of using the eye as a sort of statistics siphon, just  blindly pumping facts between the page where they've been remembered and the brain where they can be pondered, a graph engages the eye itself in <em>analyzing</em> the data it represents.

<p>
To draw charts using D3, we start by building off what we already know. There are many ways of showing data visually; the examples provided here are meant to show the "how" and not necessarily the "why". You may think of better ways to show data, and that's great! Hopefully by seeing how some more basic, perhaps even unglamorous (or worse — unsophisticated!) graphs and charts are assembled from both fundamental and more specialized components, you'll be able to apply those patterns in more novel (and certainly more polished) ways.

<p>
Essentially all the tools available to a graphics illustrator <em>and</em> nearly any algorithm available in sophisticated data analysis packages are within reach, for use togehter, when using D3. Its unique design allows full control over the recipe for a given chart, letting you combine whatever ingredients are necessary for your particular visualization. Covering all the drawing features available within browsers and all the statistical and computational geometry algorithms that have been ported to JavaScript is beyond the scope of this book, but rest assured that D3 itself uses enough of both to whet our appetites for what's possible. We'll start with the drawing features and then start adding in some of the algorithms that come bundled with D3.

<h3>Manipulating SVG’s DOM</h3>

<p>
We've been focusing on manipulating HTML's DOM. This DOM exposes the visible document as a tree of elements of varying types, each with its own meaning and each accepting attributes which we can use to modify how they are presented. Our options for presentation and styling these HTML elements leave a little to be desired, especially when it comes to drawing graphics content.

<p>
Fortunately, modern browsers expose another standardized DOM — one tailored specifically to the display of vector graphics! SVG, which stands for "Scalable Vector Graphics", is an XML image format (dating back to when XML was still young) for which browsers gradually added support — first via foreign <code>object</code> tags, then within standard <code>img</code> tags and finally embedded directly in HTML5 via the <code>svg</code> tag. It's this last milestone that is useful to us.


<div></div>
<script type="x-book/x-sample">
var html = d3.select(this).append('span').text("Text displayed using HTML.");

var svg = d3.select(this).append('svg').attr('width', 200).attr('height', 40);
svg.append('defs').append('path').attr('id', "squiggle").attr('d', squiggle);
svg.append('text').append('textPath').attr('xlink:href', "#squiggle")
    .text("More control via SVG!");
</script>

<p>
Manipulating SVG tags directly embedded in HTML is hardly any different than manipulating HTML itself: we use D3 to generate a selection of elements and then set attributes on these elements, using each element to display whatever information in whichever way we desire. To do this effectively we must first complete our tour of basic SVG usage. Soon, finally, we will be ready to venture outside of D3's core selection API, and begin borrowing from its fantastic toolchest full of useful utilities.

<h3>Overview of available SVG elements</h3>

<p>
If you're already familar with vector graphics, either from other drawing frameworks or even from sketching shapes in an illustration app, great! SVG follows a pretty standard vector drawing model, built on the notion of shapes drawn relative to an invisible, adjustable grid of layers, over top any "earlier" shapes drawn below. In SVG, these vector shapes are called <i>paths</i>, and the layered grids in which the virtual brush moves are called <i>viewports</i>.

<p>
[TBD: path "shapes" + viewport "layers" graphic?]

<p>
Paths can be filled and/or simply left as stroked lines or outlines, and of course things like the colors used and the stroke and fills styles applied are all adjustable. SVG supports transparent colors, as well as even more advanced ways of combining (or "blending") colors with the content below. A more detailed explanation is beyond the scope of this chapter [TBD: appendix? <i>actually I'm wondering if most of <em>this</em> content <em>already belongs</em> to such an appendix!</i>] but here is a summary of how the elements and attributes of SVG determine what will be drawn in the document:

<table border>
<thead>
    <tr><th>SVG element</th><th>Details</th><th>Summary</th></tr>
</thead>
<tbody>
    <tr><td>rect</td><td>
        <dl>
            <dt>x</dt><dt>y</dt>
            <dd>Position of the "lower left" corner (numerically, not necessarily visually)</dd>
            
            <dt>width</dt><dt>height</dt>
            <dd>Size of each side</dd>
            
            <dt>rx</dt><dt>ry</dt>
            <dd>Corner rounding</dd>
        </dl>
        This represents a rectangle, or basic "box".
    </td><td rowspan=100>TBD: diagrams</td></tr>
    
    <tr><td>image</td><td>
        <dl>
            <dt>x</dt><dt>y</dt>
            <dd>Position of the "lower left" corner (numerically, not necessarily visually)</dd>
            
            <dt>width</dt><dt>height</dt>
            <dd>Size of each side</dd>
            
            <dt>xlink:href</dt>
            <dd>Image file</dd>
        </dl>
        Like a rectangle, but filled with RGBA pixel data from an external image source.
    </td></tr>
    
    <tr><td>circle</td><td>
        <dl>
            <dt>cx</dt><dt>cy</dt>
            <dd>Center position</dd>
            
            <dt>r</dt>
            <dd>Radius</dd>
        </dl>
    </td></tr>
    
    <tr class=remove><td>ellipse</td><td>
        <dl>
            <dt>cx</dt><dt>cy</dt>
            <dd>Center position</dd>
            
            <dt>rx</dt><dt>ry</dt>
            <dd>Radius along each axis</dd>
        </dl>
        
        NOTE: Being able to specify an ellipse directly can sometimes be handy, although a simple circle can also be drawn stretched (using an appropriate viewport transform, see below) to an ellipse shape as well.
    </td></tr>
    
    <tr class=remove><td>line</td><td>
        <dl>
            <dt>x1</dt><dt>y1</dt>
            <dd>Starting position</dd>
            
            <dt>x2</dt><dt>y2</dt>
            <dd>Ending position</dd>
        </dl>
    </td></tr>
    
    <tr class=remove><td>polyline, polygon</td><td>
        <dl>
            <dt>points</dt>
            <dd>List of positions along the path</dd>
        </dl>
        
        These represent (respectively) an open or closed set of connected vertices.<br>
        NOTE: the shape utilities provided by D3.js generate data for the <code>path</code> element instead.
    </td></tr>
    
    <tr><td>text</td><td>
        <dl>
            <dt>x</dt><dt>y</dt>
            <dd>Position of this element's content</dd>
            <dt>font</dt>
            <dd>Typeface options</dd>
        </dl>
        
        Character data inside a <code>text</code> element will be rendered on the image.<br>
        NOTE: although we won't use much of it, this element is not nearly so simple as presented here. Through this and other related elements, SVG offers rich text features such as links, individually stylable spans, and even rendering characters along a curved baseline controlled by an arbitrary path.
    </td></tr>
    
    <tr><td>path</td><td>
        <dl>
            <dt>d</dt>
            <dd>Shape outline data</dd>
        </dl>
        
        More details on this element below. Path data includes shape "control point" positions and a variety of commands, see [TBD: another table].
    </td></tr>
    
    <tr><td>g</td><td>
        <dl>
            <dt>transform</dt>
            <dd>List of coordinate system transforms</dd>
        </dl>
        
        Not a shape, but a <em>structural</em> element. More on this one below, too.
    </td></tr>
    
</tbody>
<caption>Summary of SVG elements and their unique attributes</caption>
</table>

<p>
There are a few more elements and a lot more attributes than are listed here, but these are what we'll be using to get started showing data with SVG. We'll also be using these major presentation attributes, which can be used with any of the shape elements above:

<dl>
    <dt>stroke, stroke-opacity</dt>
    <dd>The CSS-style color and opacity (from 0.0 to 1.0) for the outline of a shape</dd>
    
    <dt>stroke-width</dt>
    <dd>The thickness of the outline, in units of its current viewport</dd>
    
    <dt>fill, fill-opacity</dt>
    <dd>The color and opacity for the <em>interior</em> area of a shape. Even if a shape isn't closed, it can be filled!</dd>
    
    <dt>transform</dt>
    <dd>Used to define a new coordinate space for this element and its children. (See later elaboration.)</dd>
</dl>

<p>
(Of special note is that many of these presentation attributes are defined as <i>styling properties</i> too! This means that visual aspects can be controlled through attributes on each element, <em>and</em> applied as rules by CSS selectors just like would be used with HTML. That is, one could request orange outlines for all SVG circles which have a "warning" class set by including <code>circle.warning { stroke: orange; }</code> in one of the containing document's CSS stylesheets!)

<p>
An SVG <code>path</code> is its most powerful primitive. In fact, except for images and (it could be argued) text, all of these other shapes can be represented as path data instead.

<p>
What is a path? Well, a path's data is a series of instructions controlling a virtual pen. This pen can be picked up and moved, directed to move straight to another location, and/or told to follow a variety of curved traces. When a series of lines or curves ends right where it started, it is considered a <i>closed</i> path, and depending on either its direction of travel (<code>fill-rule=nonzero</code> winding) or the number of closed paths surrounding it (<code>fill-rule=evenodd</code>), a closed subpath can represent a filled area or an unfilled <em>hole</em> in another shape.

<p>
Here are some example path data strings with brief interpretations. D3 will normally generate these strings for us, so just a basic understanding will suffice. The basic rules are:

<ul>
<li>Each letter represents a command, and is typically followed by a series of numbers (whitespace and/or commas can be used to separate them) which represent point coordinates or other parameters.
<li>Uppercase commands are absolute (i.e. coordinates are interpreted relative to the coordinate system); lowercase commands are relative (i.e. coordinates are treated as vectors from the current position).
<li>Repeated commands are implied whenever numeric data is given without a preceding letter.
</ul>

The letters and numbers within a path's "<code>d</code>" attribute only control the <em>outline</em> of the path. They determine <em>what</em> shape will be drawn. Other attributes (<code>color</code>, <code>fill-rule</code>, <code>stroke-width</code>, <code>opacity</code>, etc.) or corresponding CSS styling properties must still be used to control other aspects of <em>how</em> the shape is rendered.

<table border>
<thead>
    <tr><th style="width: 10em"><code>&lt;path d="…"/></th><th>Prose</th><th>Picture</th></tr>
</thead>
<tbody>
    <tr><th>M 10,25<br>L 90,75</th><td>
        Move to (i.e. start at) top left. Draw a line towards the bottom left.<br>
        This is equivalent to <code>&lt;line x1=10 y1=25 x2=90 y2=75/></code>.
    </td><td>
        <svg width=100 height=100><path d="M 10,25 L 90,75" fill=none stroke=black /></svg>
    </td></tr>
    
    <tr><th>M 10,25<br>l 0,50<br>l 80,0<br>l 0,-50<br>Z</th><td>
        Move to top left. Draw a line downwards. Draw a line to the right. Draw a line upwards. Close the path (i.e. draw a straight line to start).<br>
        This is equivalent to <code>&lt;rect x=10 y=25 w=80 h=50/></code>.
    </td><td>
        <svg width=100 height=100><path d="M 10,25 l 0,50 l 80,0 l 0,-50 Z" fill=none stroke=black /></svg>
    </td></tr>
    
    <tr><th>M 50,50<br>m -45,0<br>a 45,35 0 1,1 90,0<br>&nbsp; 45,35 0 1,1 -90,0</th><td>
        Start in the middle, then move towards the left edge from there. Take a wide, unroated ellipse and fit a major, clockwise arc from it between the current point and a point way over to the right; then an arc from the same size ellipse, but end way over to the left.<br>
        This is equivalent to <code>&lt;ellipse x=50 y=50 rx=45 ry=35/></code>.
    </td><td>
        <svg width=100 height=100><path d="M 50,50 m -45,0 a 45,35 0 1,1 90,0 45,35 0 1,1 -90,0" fill=none stroke=black /></svg>
    </td></tr>
    
    <tr><th>M 50,50<br>l -45,-45<br>l 0,90<br>L 50,50<br>l 45,-45<br>l 0,90<br>Z<br>m 0,-25<br>t -10,25<br>&nbsp; 10,25<br>&nbsp; 10,-25<br>&nbsp; -10,-25</th><td>
        Start in the middle. Draw a line towards the top left. Line straight down. Line to the middle. Line towards the top right. Line straight down. Close this subpath. Start the next subpath a little closer the top. Draw a curve down leftwards, then down rightwards, then up rightwards, then up leftwards. (An upset fish?)<br>
        Note: this is filled <code>evenodd</code>, i.e. every other region is left "outside" the shape.
    </td><td>
        <svg width=100 height=100><path d="M 50,50 l -45,-45 l 0,90 L 50,50 l 45,-45 l 0,90 Z m 0,-25 t -10,25 10,25 10,-25 -10,-25" fill-rule=evenodd fill=grey stroke=black /></svg>
    </td></tr>
    
</tbody>
<caption>Path data examples, including some basic shapes</caption>
</table>

<p>
TBD: explain groups/transforms (incl.: elaborate on how "all elements can be transformed")<br>


<h3>Applying D3.js’s DOM manipulation operators to SVG</h3>


<p>
So then! We took the kernel of D3 and watched it sprout in the previous chapter, and we've just survived (presumably…) our first look over the landscape of SVG. Now let's finally start combining all these basic elements into more significant structures.
<p>
So let's take a look, finally, at basic drawing of some simple data. We'll learn how to assemble some of the patterns — several of which we've already seen! — that are looking beneath every visualization, and start getting introduced to the full D3 toolbox. It took a lot to get here; but now we have a good solid root system we can tap into as we seek to blossom out.

<p>
Say I need a simple graph to show the change in nitrate (NO<sub>3</sub><sup>−</sup>) readings taken from a fish tank of mine over a few months. (Nitrates are unwanted in drinking water, but it's a relatively safe form of nitrogen for fish and a great fertilizer for plants — so in our case moderately elevated levels are great!) To get a feel for the general trends, it should be easy to generate a sort of "sparkline" from a sampling of data we have in an array, e.g. <code>waterTests = [{"NO3":10}, {"NO3":10}, {"NO3":20}, {"NO3":15}, …]</code>.

<p>
A real sparkline would be a word-sized line graph, but we'll draw it below using dots, and in enlarged form, for simplicity and clarity right now. Our real focus is on the underlying pattern. For each data point we want a dot, that is, an SVG <code>circle</code> whose center corresponds in the horizontal (x) axis to it order in the data set and in the vertical (y) axis to the value of each data point's NO3 property. The radius and other visual properties of the dots are not derived from the data, they are just suitable constants.

<p>
That's really all there is to it, and so we mostly need to bind our data to a selection within our SVG element, append our dot elements, and then apply each datum's index to the <code>cx</code> attribute, and each datum's <code>.NO3</code> property to the <code>cy</code> attribute of these dots. To keep it just about that simple, we'll first set up the image's view box so the raw index and nitrate values land in the right visual range:

<svg style="padding:0; background: none; fill: forestgreen" width=250 height=50 preserveAspectRatio=none></svg>
<script type="x-book/x-sample">
var svg = d3.select(this).attr('viewBox', "-0.5 -125 "+waterTests.length+" 130");
svg.selectAll('ellipse').data(waterTests)
    .enter().append('ellipse')
        .attr('rx', 0.5).attr('ry', 4)
        .attr('cx', function (d,i) { return i; })
        .attr('cy', function (d) { return -d.NO3; });
</script>

<p>
We've done it!

<p>
…but there's a lot <em>not</em> to love about how we did it. It's simple, yes, but for starters: what happened to our <code>circle</code> element? Instead we've had to draw a really tall ellipse that gets squished back roughly into shape again by our stretched view box. We also had to root our view box in a negative range, and flip all our nitrate values as we drew them, so that higher values would show up higher in the page. (Remember that SVG's coordinate system is like that of many other image systems: its orgin is in the <em>top</em>-left instead of the <em>bottom</em>-left most charts use. And we can't use a negative viewbox height to flip it either — that value must be a positive number, restricting it to a simple stretchable crop box.)

<p>
This is already less than ideal, and we started with only a very simple drawing goal. Now, we've mentioned early that in addition to the image view box, SVG allows a <i>transform</i> to be set on any element. A transform would let us flip the coordinate system — eliminating the need to negate our <code>cy</code> values — but it wouldn't help our "circle squishing" problems. What really need sometimes is to convert our data <em>before</em> we apply it to our drawing elements. As we'll soon find, getting into this habit of transforming data as we apply it to our DOM makes things like drawing lines much much easier too.

<p>
But to do this without littering our data operator code with inscrutable equations like "<code>return 65 - 0.5 * d.N03</code>", we need to go beyond D3's basic DOM manipulation operators. For starters, it'd be nice if we could easily fit the data to a more natural (and more square!) view box, instead of trying to warp the view box to our data. And if we're going to trace in a line to connect each of our data points, it'd sure be great if we didn't have to build the attribute strings ourselves.

<p>
Fortunately, D3 includes tools to make both of these more natural. To fit our data to the view box, we can transform it using a <i>scale</i> right within our attribute operator. Once we've done that, we can even start using <i>shape generators</i> to yield path data on our behalf.

<h3>Using scales and generators</h3>

<p>
What is a scale?

<p>
Well, in D3.js a scale <em>transforms</em> numbers — meaning it can takes a value in and outputs a different, converted value. In this sense it's really just a pure function, and indeed D3's scale "instances" end up being just JavaScript functions.

<p>
D3 includes a handful of scales, in a couple different categories. Most of them take a number (or something easily converted to a number, such as a date converted to the number of seconds since the epoch) as input and output a proportional number in its place. These are called "quantitative" scales, and one of these is what we will soon use for our nitrate graph. The other, called the "ordinal" scale, can be useful for applying pre-set styles to both ordinal (i.e. values which can be ordered but no relative distances measured between them) and nominal (values which represent names or qualities) data; this data is usually non-numeric. A few of D3's quantitative scales can yield non-numeric output as well.

<p>
Let's start with what might be one of the simplest quantitative scales, <code>d3.scale.linear()</code> and apply it to our sparkline. We said that a scale is just a JavaScript function. This is true; when we call <code>d3.scale.linear()</code> we get a function back that will happily take in one value and return another. However, functions in JavaScript are also objects as well and can have properties (and therefore methods) of their own. D3 takes advantage of this to give us more readable control over the scale; instead of taking in all the parameters we're about to explore as nameless arguments on initialization, we can use setter methods on our scale function "instance" to configure it.

<p>
Let's see this in action:

<svg style="padding:0; background: none; fill: forestgreen" width=250 height=50></svg>
<script type="x-book/x-sample">
var xScale = d3.scale.linear().domain([0, waterTests.length]).range([0, this.getAttribute('width')]),
    yScale = d3.scale.linear().domain([0, d3.max(waterTests, function (d) { return d.NO3; })]).range([this.getAttribute('height'), 0]);
console.log(this, this.width, this.height);

d3.select(this).selectAll('circle').data(waterTests)
    .enter().append('circle').attr('r', 2)
        .attr('cx', function (d,i) { return xScale(i); })
        .attr('cy', function (d) { return yScale(d.NO3); });
</script>

<p>
Now instead of having to set up the <code>svg</code> image view box first, we set up our scales instead.
<hr style="border-color: red">
[TBD: discuss domain/range methods in more detail, note use of d3.max, note flipped yScale range, different handling of undefined]


<h3>Adding labels to basic charts</h3>
…

<h3>Custom visualizations using layouts</h3>
…

<!--
(Finish with chart referenced in animation chapter)
<svg></svg>
<script type="x-book/x-sample">
var layout = d3.layout.pie().value(function (d) { return d.amount; }),
    generator = d3.svg.arc().outerRadius(10),
    scale = d3.scale.category10();

// TODO: add labels, c.f. http://bl.ocks.org/enjalot/1203641

d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout)
  .enter().append('svg:path').attr('d', generator).attr('fill', function (d,i) { return scale(i); });
</script>
-->


<!-- TYPING -->

<h2>Animated transitions for changing data</h2>

<i>Mutability is our tragedy, but it's also our hope.</i> <!-- Fake Boethius: http://www.youtube.com/watch?v=66gmYLtJJuc (via Rapanthem) -->

<p>
We've turned all sorts of data into all sorts of charts.

<p>
These charts communicate well and look great, but are probably out of date within a few trillion CPU cycles…that's what, ten minutes in human years? Oftentimes, the information you must share is constantly changing. Otherwise, if the underlying <em>data</em> doesn't change, why not let viewers change which data is <em>presented</em> to better understand the message it conveys?

<p>
It might be that you need to display a live stream of realtime information in a dashboard; it might be that a local or remote user is editing a work-in-progress dataset; it might be that you are loading data over the network in small pieces; or you may be allowing the user to select and deselect various subsets of the data. Chances are, though, at some point the visualization that's smack dab in the middle of their screen will no longer be the data the user needs to see.

<p>
There are two main aspects we need to cover in regards to data changes. The first is dealing with DOM elements that already represent data, instead of the empty slates we've been drawing into. For that we'll need to learn more about how D3 selections and data binding works — where the "entering" selection comes from and how to use the "updating" and "exiting" selection sets as well. The persistence element of the other aspect will also need an acquaintance with "relational joins" that re-match updating data items with the updating DOM.

<p>
By the time we can fully synchronize any DOM selection with the most up-to-date data, we'll already be tackling the second aspect: smoothly transitioning the DOM between its old and new states. Animated transitions can be very simple or very complex to implement; just a dozen or so characters dropped in is everything needed for many, but D3 offers a wide range of animation options and overrides which we'll cover.

<p>
Once we learn all those techniques, though, we'll conclude with a friendly reminder that JavaScript is no longer the only way to animate DOM transitions. The animation concepts we learned via <em>D</em>3 often can — and perhaps should! — be translated into <em>CSS</em>3 when targeting modern browsers, and this is no problem for the library either.

<p>
In short, this chapter explores how to handle changes "the D3 way". In the next chapter we'll see how to <em>drive</em> dataset changes via user interaction, and later on (in Chapter 6) we'll look at ways your higher-level code can best <em>manage</em> the changing state of the data it's displaying. For now, though, let's continue our focus on "drawing" what the viewer sees, properly controlling the visible results, even when the underlying data is in a state of flux.

<h3>Same old operators, brand new data</h3>

<p>
Remember how we said D3.js makes it easy not just to create a data display, but to update an existing document with changed data?

<h4>The entering selection</h4>

<p>
You may have noticed a strange little dance we've done in all our charts so far. It often looks something like this:
<code class="example">d3.select('#container').selectAll('el.class').data(someArray)
    .enter().append('el').classed('class', true);</code>

<p>
This seems a little repetive. We're doing one thing — adding an element with some class — but we seem to say so twice, once when we <code>selectAll</code> and once as we <code>append</code>. It seems it'd simpler, easier, if we could just say something like this instead:
<code class="example">d3.select('#container')
    .addData(someArray).append('el').classed('class', true);</code>

<p>
Why does D3 make us <code>.selectAll('el.class')</code> within an empty element? The first time we do so, there's nobody home. We know this, and deep down inside D3 probably knows this too; it certainly finds out soon enough. We select what we're about to add anyway, because the entering selection — all we've been using so far — is only the beginning.

<p>
As a matter of fact, in most of our examples it would have worked just as well to bind a data array to <code>.select('#emptyContainer').select('santa-claus')</code> — doing so would have had the exact same effect, and we could still append whatever real elements we needed for the entering selection. As soon as we have selected elements or the lack thereof, D3 forgets what selector string (or function!) generated that selection. It will happily insert whatever we later ask it to, regardless if what we add matches the original selector.

<h4>Updating the selection</h4>

<p>
The reason we provide a <em>matching</em> selector for those elements we're about to add, is that it's the first step to <em>updating</em> these same elements should the data change later. As we create child elements for the <code>.enter()</code> selection, D3 binds the data to them and folds each newly created data–DOM molecule into the <i>updating</i> selection. The updating selection is just the "main" selection, the one the chained method calls were returning before we asked for the entering selection. If we keep a reference to the updating selection we can use it to…well… <em>update</em> the corresponding elements!

<ul data-reveal>
    <li style="color: grey">existing</li>
</ul>
<script type="x-book/x-sample">
var boundSelection = d3.select(this).selectAll('li').data(["still exists!", "a brand new item"])
boundSelection.enter().append('li');
boundSelection.text(String);
</script>

<p>
When we appended missing elements, D3 didn't care what the original selection was that yielded them missing; likewise when we make this selection anew D3 doesn't care where its <em>non–</em>missing elements originally came from either. Any elements already in the DOM simply get paired with the bound data, start off already in the main updating selection, and make that much less work for the entering selection.

<p>
Becaue of this, when our sample code runs, the existing <code>&lt;li></code> is actually preserved (as seen by its special style). It doesn't get recreated each time. It starts out as the only element in the main selection. There are two items in the array but only this one element, so after binding the array as that selection's data, the enter set must insert one new element. Then (at least, ever since v2.0 of the D3.js library) it folds the appended element in to the main selection. Finally, all elements are updated so their text content matches the provided data.

<h4>The exiting set</h4>

<p>
Should the selector result in more elements than bound data items, these go into a special exiting set:

<ul data-reveal>
    <li>too</li>
    <li>many</li>
    <li>elements</li>
</ul>
<script type="x-book/x-sample">
var boundSelection = d3.select(this).selectAll('li').data(["just", "right"])
boundSelection.text(String);
boundSelection.exit().remove();
</script>

<p>
We didn't <em>have</em> to remove the extra element, we could have applied any other operator (such as <code>.text('x_x')</code> — soon we'll see more practical cases) just as well.

<h4>All sets in concert</h4>

<p>
In general, it's idiomatic to handle all three selection sets as follows:

<code class="example">var selection = d3.select(container).selectAll('child');
selection.enter().append('child').operator('key', STATIC_VALUE);
selection.operator('key', function (dynamic) { return dynamic.value; })
selection.exit().remove();
</code>

<p>
First we add what's missing, then we update what's there, then we clean up what shouldn't be. By following this general pattern, even when it's not immediately necessary, we lay the groundwork for reusable charts. Any "extra" work, e.g. handling an exit selection for we assume will never go missing, has relatively little overhead unless it becomes necessary, perhaps later in your code's development lifecyle.

<p>
Let's go back to our humble pie chart from the last chapter. We've wrapped all the drawing code in a function, so we could apply it more than once, but it's otherwise identical:

<svg></svg>
<script type="x-book/x-sample">
function drawChart() {
  var layout = d3.layout.pie().value(function (d) { return d.amount; }),
      generator = d3.svg.arc().outerRadius(10),
      scale = d3.scale.category10();
  
  d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout)
    .enter().append('svg:path').attr('d', generator).attr('fill', function (d,i) { return scale(i); });  
}
drawChart.call(this);
</script>

<p>
This chart shows the amount of time spent on various activities in a day. For each sample data item, we simply append the SVG <code>&lt;path></code> element which will represent the item visually, then set the element's properties with whatever segments are necesary to draw it. This, however, doesn't support changing the visual representation when the data changes. If we change the data and run this code again, what will happen? D3 will join the changed data with the result of <code>.selectAll('path')</code>, which we see now involves dividing the selection into its three sets: the entering set (missing elements), the updating set (elements already present), and the exiting set (extra elements).

<p>
If we only handle the entering part of our selection, new elements will display as intended the first time but then will never change! This code will only work with <em>additional</em> data, not with revised or removed data. Of course, with something like a pie chart where the data always needs to fit within the same space (that whole "only 24 hours in a day" thing in this case), it'd be rather difficult to add data without revising the rest — if we spend time on a new activity we'll need to spend less time on at least one of the others. So our code right now isn't gonna work. Let's fix that.

<h4>Tuning our orchestration</h4>

<p>
Each day is different, and so we'd like to show the changes in various activities performed, and how much time spent on each, from day to day. Here's how we need to write our <code>drawChart()</code> function so it works properly when called multiple times, regardless of how the data changes in between calls:

<svg></svg>
<script type="x-book/x-sample">
function drawChart() {
  var layout = d3.layout.pie().value(function (d) { return d.amount; }),
      generator = d3.svg.arc().outerRadius(10),
      scale = d3.scale.category10();
  
  var boundSelection = d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout);
  boundSelection.enter().append('svg:path');
  // what we append/insert/select in the entering selection gets added to the main (i.e. updating) selection since v2.0
  boundSelection.attr('d', generator).attr('fill', function (d,i) { return scale(i); });
  boundSelection.exit().remove();
}

// generate the "original" DOM
drawChart.call(this);

// redraw changed data every 2.5 seconds
window.setInterval(function () {
  randomizeData();
  drawChart.call(this);
}.bind(this), 2500);


/* TBD: probably hide this stuff in printed listing */
var originalLength = timeUse.length;
function randomizeData() {
  // modify the number of items
  if (timeUse.length === originalLength) timeUse.push({
    activity: "Gathering lumber"
  });
  else timeUse.pop();
  
  // "randomly" allocate percentages
  var total = 100;
  timeUse.forEach(function (d) {
    d.amount = total * Math.random() / 2;
    total -= d.amount;
  });
  timeUse[timeUse.length - 1].amount += total;
}
</script>

Now whenever we call our <code>drawChart()</code> function, it correctly handles new, modified, and removed data items. We can now handle any reasonable change to our underlying daily time usage dataset, just by reapplying our function!

<h4>Review</h4>

<p>
Here's what we had to change to make our chart update properly:

<ul>
<li>move all the data-dependent operations from the <i>enter</i> to the <i>updating</i> selection (the static properties should still only be set initially for efficiency, however)</li>
<li>handle any data removal that might occur via the <i>exiting</i> selection</li>
</ul>

Remember: first add what's missing, then update what's there, and finally clean up what is no longer needed.

<p>
This achieves the immediate goal. Whenver the data changes we are able to update the DOM accordingly, and the viewer can always see the correct data.

<h3>Letting charts get lively</h3>

<p>
Well…sort of. In practice, it's really hard to actually <em>see</em> which data changed, and how. It just flashes to its new state! To our eyes, the visualization sort of vanishes and sort of was always there. Any sense of continuity is shattered <i>dramatic pause</i> — in the blink of an eye.

<!--
c.f. http://vis.berkeley.edu/papers/animated_transitions/
http://bost.ocks.org/mike/path/
http://bl.ocks.org/mbostock/1098617
http://bl.ocks.org/mbostock/1346410
-->

<h4>Animation goes beyond entertainment</h4>

<p>
[illustrated frames of an eye closing/opening animation (perhaps annotated with some round underlying "tweened" data?)]

<p>
It would be much easier for our eyes to grasp what's happening if the visual change mimics a more physical change. To accomplish this, we will <em>animate</em> the change — we will cause the browser to rapidly display intermediate states of our visualization as if it were <em>transitioning</em> from the original to the modified presentation.
<p>
To the eye, this will communicate motion. This motion helps the viewer better comprehend the change; just as a visualization aids spatial interpretation of numeric <em>data</em>, animation adds a kinetic understanding of quantitative or qualitative <em>change</em>. In the case of our pie chart, we would get a better sense of how much a particular activity varied from day to day if we could watch it grow or shrink.

<p>
Animation has an aesthetic aspect, too, just as static visualization does. One academic study of "Animated Transitions in Statistical Data Graphics" (Heer 2007) concluded subjects "felt that [animation] facilitated both improved understanding and increased engagement." There were more scientific results to their study of course, but these feelings matter too. A chart can be beautiful; a transition can be <em>fun</em>!

<h4>Automatic animation in D3</h4>

<p>
As you might have come to expect, with D3 there is a succint but powerful way to animate a DOM change. Simply apply the <code>.transition()</code> operator to any selection to yield some very useful specialized behaviour:

<svg></svg>
<script type="x-book/x-sample" data-hidden>
function drawChart() {
  var layout = d3.layout.pie().value(function (d) { return d.amount; }),
      generator = d3.svg.arc().outerRadius(10),
      scale = d3.scale.category10();
  
  var boundSelection = d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout);
  boundSelection.enter().append('svg:path');
  boundSelection.transition().attr('d', generator).attr('fill', function (d,i) { return scale(i); });
  boundSelection.exit().remove();
}

// generate the "original" DOM
drawChart.call(this);

// redraw changed data every 2.5 seconds
window.setInterval(function () {
  randomizeData();
  drawChart.call(this);
}.bind(this), 2500);


var originalLength = timeUse.length;      // used for toggling length
function randomizeData() {
  // modify the number of items
  if (timeUse.length === originalLength) timeUse.push({
    activity: "Gathering lumber"
  });
  else timeUse.pop();
  
  // "randomly" allocate percentages
  var total = 100;
  timeUse.forEach(function (d) {
    d.amount = total * Math.random() / 2;
    total -= d.amount;
  });
  timeUse[timeUse.length - 1].amount += total;
}
</script>

<code class=example>  // in drawChart…
  boundSelection<b>.transition()</b>.attr('d', generator).attr('fill', function (d,i) { return scale(i); });
</code>

<p>
Adding this method call does two things: it starts a clock ticking, and it returns a selection wrapped with transition-savvy replacements for all the usual <code>attr</code>/<code>property</code>/<code>style</code>/… operators plus some new ones which we'll see soon.
<p>
Instead of setting the elements' <var>d</var> and <var>fill</var> attributes to the provided values immediately, these operators now simply store the desired target state internally and return control to your code. In the background, the transition operator's clock (a <code>d3.timer()</code>, to be specific) is ready to fire at animation-rate intervals. On every tick, the transition's internal methods will update the respective DOM state to an <em>interpolated</em> value between its original and the target setting for that animation frame.

<h4>The basic idea of interpolation</h4>

<p>
Interpolation in D3 is actually very simple: the default interpolator simply looks looks for any number(s) in the current and target values and steps between them. There are a few simple ways to adjust how the animation progresses. A transitioning selection adds <code>.delay(<i>…</i>)</code> and <code>.duration(<i>…</i>)</code> operators which both take a millisecond value as their only parameter. There is also an <code>.ease(<i>…</i>)</code> parameter that allows customizing the animation timing curve, for example passing the shortcut string "cubic-in-out" will essentially "fade" the animation's speed as it starts and finishes.

<p>
The default interpolation works surprisingly well for a variety of situations: it can even do a servicable job of warping from one complete set of SVG path vertices to another, as we see in this pie chart example. If the default interpolation is not capable enough, you can actually pass customized interpolators to additional transition operators (<code>.attrTween()</code> and <code>.styleTween()</code> or even the raw <code>.tween()</code> operator. We'll dive deeper into this later in the chapter.


<h4>Deterministic transition transactions</h4>

<p>
Note that in all cases the target value is calculated immediately. That is, before the call to <code>.transition().<i>someOperator</i>(<i>someFunctionValue</i>)</code> returns, your <code>someFunctionValue</code> will have already been used to decide the target values for all elements. If the underlying data changes while the transition timer is causing redraw events, this will <em>not</em> effect what the user sees — unless of course you apply a replacement transition by e.g. calling our <code>drawChart()</code> code again. This case is really not much different; the new transition will animate the DOM from its current (potentially halfway through an earlier transition) to the (new) target state.

<p>
This is a good thing. It gives you full, deterministic control over what is drawn and when. You don't have to worry about subsequent user actions or data modification events sullying your careful calculations. You needn't worry about partial modifications or intermediate states your data may go through between calls to selection operators — any course correction to the animation in progress on screen happens whenever <em>you're</em> ready to apply it.


<h3>Object persistence with relational joins</h3>

<p>
TBD: this topic needs some coverage here, but might be better to save in-depth discussion for the interaction chapter where its inner workings are more relevant.

<h3>How relational joins work</h3>

<p>
Our chart is now correct after every update, but there's one potentially important piece we're missing. In our pie chart example so far, our data changes came in a relatively simple form, and due to the "update every relevant path property" nature of our drawing, we haven't actually missed it. So now that you have an aching longing in your heart for this missing knowlege…

<p>
TBD: as this especially derptastic introduction indicates…our pie chart is not really the best example to introduce this. Mike Bostock uses <a href="http://mbostock.github.io/d3/tutorial/bar-2.html">an example where elements get unshifted</a> from the front of a bar chart's array to better illustrate the need for what he terms "object constancy". However, the need for this may be even simpler to illustrate in another chapter.

TBD-plan: maybe the best way to approach this is with small multiples! subtly encapsulate the chart drawing and then do a carousel (or sortable) display where existing pie charts are continously shifted around

<!-- c.f. http://bost.ocks.org/mike/join/ and http://bost.ocks.org/mike/selection/ -->

<p>
… [using .data binding to associate existing DOM elements (usually via the data bound on them) with new versions of their data] …


<h3>Transition tips and tricks</h3>

<p>
TBD: when/how to use sort/order

<p>
TBD: dive into smoother entrance/exit example (i.e. appending before starting transition, how remove works after fading opacity)

<p>
TBD: handling subselections when modifying

<p>
TBD: dive deeper into staging sequential animations

<p>
TBD: discuss manual tweening

<p>
TBD: animation easing and such also easily merit its own expansion — might need a bit more detail above, however

<h3>Using CSS3/SVG alternatives to .transition()</h3>

<p>
TBD: make sure readers are aware of CSS3 transitions and SVG animation, which are potentially more efficient ways of transitioning data. Show at least one example of each, triggering the necessary stuff via D3 of course.


<!-- /TYPING -->


<h2>Interactive data displays</h2>


<script>

DATA = {};

DATA.squiggle = "M 13.975904,33.253012 C 33.413655,7.2289157 42.409639,8.8353413 42.409639,8.8353413 58.634538,5.4618474 53.012048,28.11245 70.040161,35.02008 90.923695,44.337349 131.72691,7.3895582 131.72691,7.3895582 156.30522,-1.4457832 182.6506,35.180723 182.6506,35.180723";

DATA.timeUse = [
  {activity:"Field work", amount:50},
  {activity:"Choring animals", amount: 10},
  {activity:"Meal time", amount: 8},
  {activity:"Playing fiddle", amount: 2},
  {activity:"Resting", amount:30}
];

DATA.waterTests = [
    {d:"2013-02-21", pH:8.2, NH3:0, NO2:0, NO3:10},
    {d:"2013-02-23", pH:8.3, NH3:0.125, NO2:0, NO3:10},
    {d:"2013-03-01", pH:8.1, NH3:0.125, NO2:0, NO3:10},
    {d:"2013-03-04", pH:8.2, NH3:0.25, NO2:0, NO3:10},
    {d:"2013-03-05", pH:8.2, NH3:0.25, NO2:0, NO3:10},
    {d:"2013-03-06", pH:8.1, NH3:0.5, NO2:0, NO3:10},
    {d:"2013-03-07", pH:8, NH3:0.25, NO2:0, NO3:10},
    {d:"2013-03-08", pH:8.2, NH3:0.5, NO2:0, NO3:20},
    {d:"2013-03-09", pH:8.1, NH3:0.5, NO2:0, NO3:15},
    {d:"2013-03-09", pH:8, NH3:0.5, NO2:0, NO3:15},
    {d:"2013-03-10", pH:8, NH3:0.25, NO2:0, NO3:20},
    {d:"2013-03-11", pH:8.1, NH3:0.5, NO2:0, NO3:10},
    {d:"2013-03-12", NH3:0.5, NO2:0.0625},
    {d:"2013-03-12", pH:8.2, NH3:0.5, NO2:0.0625, NO3:10},
    {d:"2013-03-13", pH:8.2, NH3:0.5, NO2:0.0625, NO3:30},
    {d:"2013-03-14", pH:8.1, NH3:0.25, NO2:0.125, NO3:40},
    {d:"2013-03-15", pH:8.2, NH3:0.5, NO2:0.25, NO3:30},
    {d:"2013-03-16", pH:8.2, NH3:0.5, NO2:0.25, NO3:40},
    {d:"2013-03-17", pH:8.2, NH3:0.5, NO2:0.25, NO3:40},
    {d:"2013-03-18", pH:8.2, NH3:0.5, NO2:0.5, NO3:30},
    {d:"2013-03-19", pH:8.2, NH3:0.5, NO2:0.5, NO3:35},
    {d:"2013-03-20", pH:8.3, NH3:0.5, NO2:0.5, NO3:80},
    {d:"2013-03-21", pH:8.3, NH3:0.5, NO2:0.75, NO3:80},
    {d:"2013-03-22", pH:8.3, NH3:0.25, NO2:1.5, NO3:60},
    {d:"2013-03-23", pH:8.3, NH3:0.25, NO2:2, NO3:40},
    {d:"2013-03-24", pH:8.4, NH3:0.125, NO2:5, NO3:40},
    {d:"2013-03-25", pH:8.3, NH3:0.125, NO2:5, NO3:60},
    {d:"2013-03-26", pH:8.3, NH3:0.0625, NO2:5, NO3:40},
    {d:"2013-03-27", pH:8.2, NH3:0.0625, NO2:3.5, NO3:60},
    {d:"2013-03-28", pH:8.2, NH3:0.0625, NO2:3.5, NO3:50},
    {d:"2013-03-29", pH:8.2, NH3:0.0625, NO2:3.5, NO3:40},
    {d:"2013-03-30", pH:8.2, NH3:0.0625, NO2:2, NO3:30},
    {d:"2013-03-31", pH:8.3, NH3:0, NO2:3.5, NO3:35},
    {d:"2013-04-01", pH:8.3, NH3:0.0625, NO2:3.5, NO3:30},
    {d:"2013-04-02", pH:8.3, NH3:0.0625, NO2:3.5, NO3:40},
    {d:"2013-04-03", pH:8, NH3:0, NO2:3.5, NO3:50},
    {d:"2013-04-04", pH:8, NH3:0.0625, NO2:3.5, NO3:30},
    {d:"2013-04-05", pH:8, NH3:0.0625, NO2:3.5, NO3:30},
    {d:"2013-04-06", pH:8.1, NH3:0.0625, NO2:3.5, NO3:30},
    {d:"2013-04-08", pH:8.2, NH3:0.0625, NO2:3.5, NO3:20},
    {d:"2013-04-09", pH:8.1, NH3:0.25, NO2:0.75, NO3:20},
    {d:"2013-04-10", pH:8, NH3:0, NO2:0, NO3:15},
    {d:"2013-04-11", pH:8, NH3:0.125, NO2:0, NO3:15},
    {d:"2013-04-12", pH:7.9, NH3:0.25, NO2:0, NO3:15},
    {d:"2013-04-13", pH:7.9, NH3:0.25, NO2:0, NO3:10},
    {d:"2013-04-14", pH:7.9, NH3:0.125, NO2:0, NO3:7.5},
    {d:"2013-04-15", pH:7.9, NO3:15},
    {d:"2013-04-16", pH:8.1},
    {d:"2013-04-17", pH:6.6},
    {d:"2013-04-17", pH:7.6},
    {d:"2013-04-17", pH:7.9, NH3:0, NO2:0, NO3:20},
    {d:"2013-04-20", pH:7.8, NH3:0.0625, NO2:0, NO3:15},
    {d:"2013-04-21", pH:7.6, NH3:0.75, NO2:1, NO3:20},
    {d:"2013-04-22", pH:7.6, NH3:0.5, NO2:3.5, NO3:60},
    {d:"2013-04-23", pH:7.6, NH3:0.25, NO2:3.5, NO3:60},
    {d:"2013-04-24", pH:7.6, NH3:0.125, NO2:3.5, NO3:60},
    {d:"2013-04-25", pH:7.6, NH3:0.0625, NO2:0, NO3:60},
    {d:"2013-04-26", pH:7.6, NH3:0.0625, NO2:0, NO3:60},
    {d:"2013-04-27", pH:7.6, NH3:0.75, NO2:0.125, NO3:80},
    {d:"2013-04-28", pH:7.6, NH3:0.35, NO2:3.5, NO3:80},
    {d:"2013-04-29", pH:7.6, NH3:0.0625, NO2:3.5, NO3:80},
    {d:"2013-04-30", pH:7.7, NH3:0.125, NO2:0, NO3:100},
    {d:"2013-05-05", pH:7.6, NH3:0, NO2:0, NO3:120},
    {d:"2013-05-13", pH:7.6, NH3:0, NO2:0, NO3:100},
    {d:"2013-05-20", pH:7.8, NH3:0, NO2:0, NO3:60},
    {d:"2013-05-29", pH:7.6, NH3:0.25, NO2:0, NO3:5}
];

</script>
<script>
d3.selectAll('script[type="x-book/x-sample"]').select(function () {
  // show the container properly and reveal its soure if requested
  var container = this.previousElementSibling;
  container.classList.add('example');
  container.classList.add('output');
  if ('reveal' in container.dataset) {
      var el = document.createElement('code');
      delete container.dataset.reveal;
      el.textContent = container.outerHTML;
      el.classList.add('example');
      el.classList.add('source');
      this.parentNode.insertBefore(el, this);
  }
  
  // run the sample to show the result (within the node immediately preceding it)
  try {
    eval("(function ("+d3.keys(DATA).join(',')+") {" + this.textContent + "})")
      .apply(container, d3.values(DATA));
  } catch (e) { console.warn(e); }
  
  // display the code within a visible block
  var el = document.createElement('code');
  el.textContent = this.textContent.trim();
  if (!('hidden' in this.dataset)) this.parentNode.replaceChild(el, this)
  return el;
}).classed('example', true);
</script>
</body></html>

