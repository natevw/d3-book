<!doctype html>
<html><head>
    <meta charset="utf-8">
    <title>Chapter sample</title>
    <script src="d3.v3.min.js"></script>
    <style>
      body { max-width: 50em; }
      svg.example.output {
        display: block; background: #FBFBFB;
        margin: 2em 4em; padding: 1em;
        max-width: 20em;
        max-height: 20em;
      }
      code.example {
        display: block; background: #DDD;
        margin: 2em 5em; padding: 1em;
        white-space: pre;
        overflow: auto;
      }
    </style>
</head><body>

<h1>D3.js in Awesome</h1>

<h2>What is D3.js?</h2>
…
<h2>Showing data using SVG</h2>
…
<!--
(Finish with chart referenced in animation chapter)
<svg></svg>
<script type="x-book/x-sample">
var layout = d3.layout.pie().value(function (d) { return d.amount; }),
    generator = d3.svg.arc().outerRadius(10),
    scale = d3.scale.category10();

// TODO: add labels, c.f. http://bl.ocks.org/enjalot/1203641

d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout)
  .enter().append('svg:path').attr('d', generator).attr('fill', function (d,i) { return scale(i); });
</script>
-->


<!-- TYPING -->

<h2>Animated transitions for changing data</h2>

<i>Mutability is our tragedy, but it's also our hope.</i> <!-- Fake Boethius: http://www.youtube.com/watch?v=66gmYLtJJuc (via Rapanthem) -->

<p>
We've turned all sorts of data into all sorts of charts.

<p>
These charts communicate well and look great, but are probably out of date within a few trillion CPU cycles…that's what, ten minutes in human years? Oftentimes, the information you must share is constantly changing. Otherwise, if the underlying <em>data</em> doesn't change, why not let viewers change which data is <em>presented</em> to better understand the message it conveys?

<p>
It might be that you need to display a live stream of realtime information in a dashboard; it might be that a local or remote user is editing a work-in-progress dataset; it might be that you are loading data over the network in small pieces; or you may be allowing the user to select and deselect various subsets of the data. Chances are, though, at some point the visualization that's smack dab in the middle of their screen will no longer be the data the user needs to see.

<p>
There are two main aspects we need to cover in regards to data changes. The first is dealing with DOM elements that already represent data, instead of the empty slates we've been drawing into. For that we'll need to learn more about how D3 selections and data binding works — where the "entering" selection comes from and how to use the "updating" and "exiting" selection sets as well. The persistence element of the other aspect will also need an acquaintance with "relational joins" that re-match updating data items with the updating DOM.

<p>
By the time we can fully synchronize any DOM selection with the most up-to-date data, we'll already be tackling the second aspect: smoothly transitioning the DOM between its old and new states. Animated transitions can be very simple or very complex to implement; just a dozen or so characters dropped in is everything needed for many, but D3 offers a wide range of animation options and overrides which we'll cover.

<p>
Once we learn all those techniques, though, we'll conclude with a friendly reminder that JavaScript is no longer the only way to animate DOM transitions. The animation concepts we learned via <em>D</em>3 often can — and perhaps should! — be translated into <em>CSS</em>3 when targeting modern browsers, and this is no problem for the library either.

<p>
In short, this chapter explores how to handle changes "the D3 way". In the next chapter we'll see how to <em>drive</em> dataset changes via user interaction, and later on (in Chapter 6) we'll look at ways your higher-level code can best <em>manage</em> the changing state of the data it's displaying. For now, though, let's continue our focus on "drawing" what the viewer sees, properly controlling the visible results, even when the underlying data is in a state of flux.

<h3>Same old operators, brand new data</h3>

<p>
Remember how we said D3.js makes it easy not just to create a data display, but to update an existing document with changed data?

<h4>The entering selection</h4>

<p>
You may have noticed a strange little dance we've done in all our charts so far. It often looks something like this:
<code class="example">d3.select('#container').selectAll('el.class').data(someArray)
    .enter().append('el').classed('class', true);</code>

<p>
This seems a little repetive. We're doing one thing — adding an element with some class — but we seem to say so twice, once when we <code>selectAll</code> and once as we <code>append</code>. It seems it'd simpler, easier, if we could just say something like this instead:
<code class="example">d3.select('#container')
    .addData(someArray).append('el').classed('class', true);</code>

<p>
Why does D3 make us <code>.selectAll('el.class')</code> within an empty element? The first time we do so, there's nobody home. We know this, and deep down inside D3 probably knows this too; it certainly finds out soon enough. We select what we're about to add anyway, because the entering selection — all we've been using so far — is only the beginning.

<p>
As a matter of fact, in most of our examples it would have worked just as well to bind a data array to <code>.select('#emptyContainer').select('santa-claus')</code> — doing so would have had the exact same effect, and we could still append whatever real elements we needed for the entering selection. As soon as we have selected elements or the lack thereof, D3 forgets what selector string (or function!) generated that selection. It will happily insert whatever we later ask it to, regardless if what we add matches the original selector.

<h4>Updating the selection</h4>

<p>
The reason we provide a <em>matching</em> selector for those elements we're about to add, is that it's the first step to <em>updating</em> these same elements should the data change later. As we create child elements for the <code>.enter()</code> selection, D3 binds the data to them and folds each newly created data–DOM molecule into the <i>updating</i> selection. The updating selection is just the "main" selection, the one the chained method calls were returning before we asked for the entering selection. If we keep a reference to the updating selection we can use it to…well… <em>update</em> the corresponding elements!

<ul data-reveal>
    <li style="color: grey">existing</li>
</ul>
<script type="x-book/x-sample">
var boundSelection = d3.select(this).selectAll('li').data(["still exists!", "a brand new item"])
boundSelection.enter().append('li');
boundSelection.text(String);
</script>

<p>
When we appended missing elements, D3 didn't care what the original selection was that yielded them missing; likewise when we make this selection anew D3 doesn't care where its <em>non–</em>missing elements originally came from either. Any elements already in the DOM simply get paired with the bound data, start off already in the main updating selection, and make that much less work for the entering selection.

<p>
Becaue of this, when our sample code runs, the existing <code>&lt;li></code> is actually preserved (as seen by its special style). It doesn't get recreated each time. It starts out as the only element in the main selection. There are two items in the array but only this one element, so after binding the array as that selection's data, the enter set must insert one new element. Then (at least, ever since v2.0 of the D3.js library) it folds the appended element in to the main selection. Finally, all elements are updated so their text content matches the provided data.

<h4>The exiting set</h4>

<p>
Should the selector result in more elements than bound data items, these go into a special exiting set:

<ul data-reveal>
    <li>too</li>
    <li>many</li>
    <li>elements</li>
</ul>
<script type="x-book/x-sample">
var boundSelection = d3.select(this).selectAll('li').data(["just", "right"])
boundSelection.text(String);
boundSelection.exit().remove();
</script>

<p>
We didn't <em>have</em> to remove the extra element, we could have applied any other operator (such as <code>.text('x_x')</code> — soon we'll see more practical cases) just as well.

<h4>All sets in concert</h4>

<p>
In general, it's idiomatic to handle all three selection sets as follows:

<code class="example">var selection = d3.select(container).selectAll('child');
selection.enter().append('child').operator('key', STATIC_VALUE);
selection.operator('key', function (dynamic) { return dynamic.value; })
selection.exit().remove();
</code>

<p>
First we add what's missing, then we update what's there, then we clean up what shouldn't be. By following this general pattern, even when it's not immediately necessary, we lay the groundwork for reusable charts. Any "extra" work, e.g. handling an exit selection for we assume will never go missing, has relatively little overhead unless it becomes necessary, perhaps later in your code's development lifecyle.

<p>
Let's go back to our humble pie chart from the last chapter. We've wrapped all the drawing code in a function, so we could apply it more than once, but it's otherwise identical:

<svg></svg>
<script type="x-book/x-sample">
function drawChart() {
  var layout = d3.layout.pie().value(function (d) { return d.amount; }),
      generator = d3.svg.arc().outerRadius(10),
      scale = d3.scale.category10();
  
  d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout)
    .enter().append('svg:path').attr('d', generator).attr('fill', function (d,i) { return scale(i); });  
}
drawChart.call(this);
</script>

<p>
For each sample data item, we simply append the SVG <code>&lt;path></code> element which will represent the item visually, then set the element's properties with whatever segments are necesary to draw it. This, however, doesn't support changing the visual representation when the data changes. If we change the data and run this code again, what will happen? D3 will join the changed data with the result of <code>.selectAll('path')</code>, which we see now involves dividing the selection into its three sets: the entering set (missing elements), the updating set (elements already present), and the exiting set (extra elements).

<p>
If we only handle the entering part of our selection, new elements will display as intended the first time but then will never change! This code will only work with <em>additional</em> data, not with revised or removed data. Of course, with something like a pie chart where the data all needs to fit within the same space each time, it'd be rather difficult to add data without revising the rest. So this isn't gonna work. Let's fix that.

<h4>Tuning our orchestration</h4>

<p>
Here's how we need to write our <code>drawChart()</code> function so it works properly when called multiple times, regardless of how the data changes in between calls:

<svg></svg>
<script type="x-book/x-sample">
function drawChart() {
  var layout = d3.layout.pie().value(function (d) { return d.amount; }),
      generator = d3.svg.arc().outerRadius(10),
      scale = d3.scale.category10();
  
  var boundSelection = d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout);
  boundSelection.enter().append('svg:path');
  // what we append/insert/select in the entering selection gets added to the main (i.e. updating) selection since v2.0
  boundSelection.attr('d', generator).attr('fill', function (d,i) { return scale(i); });
  boundSelection.exit().remove();
}

// generate the "original" DOM
drawChart.call(this);

// redraw changed data every 2.5 seconds
window.setInterval(function () {
  randomizeData();
  drawChart.call(this);
}.bind(this), 2500);


/* TBD: probably hide this stuff in printed listing */
var originalLength = timeUse.length;
function randomizeData() {
  // modify the number of items
  if (timeUse.length === originalLength) timeUse.push({
    activity: "Gathering lumber"
  });
  else timeUse.pop();
  
  // "randomly" allocate percentages
  var total = 100;
  timeUse.forEach(function (d) {
    d.amount = total * Math.random() / 2;
    total -= d.amount;
  });
  timeUse[timeUse.length - 1].amount += total;
}
</script>

<h4>Review</h4>

<p>
Here's what we had to change to make our chart update properly:

<ul>
<li>move all the data-dependent operations from the <i>enter</i> to the <i>updating</i> selection (the static properties should still only be set initially for efficiency, however)</li>
<li>handle any data removal that might occur via the <i>exiting</i> selection</li>
</ul>

Remember: first add what's missing, then update what's there, and finally clean up what is no longer needed.

<p>
This achieves the immediate goal. Whenver the data changes we are able to update the DOM accordingly, and the viewer can always see the correct data.

<h3>Letting charts get lively</h3>

<p>
Well…sort of. In practice, it's really hard to actually <em>see</em> which data changed, and how. It just flashes to its new state! To our eyes, the visualization sort of vanishes and sort of was always there. Any sense of continuity is shattered <i>dramatic pause</i> — in the blink of an eye.

<!--
c.f. http://vis.berkeley.edu/papers/animated_transitions/
http://bost.ocks.org/mike/path/
http://bl.ocks.org/mbostock/1098617
http://bl.ocks.org/mbostock/1346410
-->

<h4>Animation goes beyond entertainment</h4>

<p>
[illustrated frames of an eye closing/opening animation (perhaps annotated with some round underlying "tweened" data?)]

<p>
It would be much easier for our eyes to grasp what's happening if the visual change mimics a more physical change. To accomplish this, we will <em>animate</em> the change — we will cause the browser to rapidly display intermediate states of our visualization as if it were <em>transitioning</em> from the original to the modified presentation.
<p>
To the eye, this will communicate motion. This motion helps the viewer better comprehend the change; just as a visualization aids spatial interpretation of numeric <em>data</em>, animation adds a kinetic understanding of quantitative or qualitative <em>change</em>.
<p>
Animation has an aesthetic aspect, too, just as static visualization does. One academic study of "Animated Transitions in Statistical Data Graphics" (Heer 2007) concluded subjects "felt that [animation] facilitated both improved understanding and increased engagement." There were more scientific results to their study of course, but these feelings matter too. A chart can be beautiful; a transition can be <em>fun</em>!

<h4>Automatic animation in D3</h4>

<p>
As you might have come to expect, with D3 there is a succint but powerful way to animate a DOM change. Simply apply the <code>.transition()</code> operator to any selection to yield some very useful specialized behaviour:

<svg></svg>
<script type="x-book/x-sample" data-hidden>
function drawChart() {
  var layout = d3.layout.pie().value(function (d) { return d.amount; }),
      generator = d3.svg.arc().outerRadius(10),
      scale = d3.scale.category10();
  
  var boundSelection = d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout);
  boundSelection.enter().append('svg:path');
  boundSelection.transition().attr('d', generator).attr('fill', function (d,i) { return scale(i); });
  boundSelection.exit().remove();
}

// generate the "original" DOM
drawChart.call(this);

// redraw changed data every 2.5 seconds
window.setInterval(function () {
  randomizeData();
  drawChart.call(this);
}.bind(this), 2500);


var originalLength = timeUse.length;      // used for toggling length
function randomizeData() {
  // modify the number of items
  if (timeUse.length === originalLength) timeUse.push({
    activity: "Gathering lumber"
  });
  else timeUse.pop();
  
  // "randomly" allocate percentages
  var total = 100;
  timeUse.forEach(function (d) {
    d.amount = total * Math.random() / 2;
    total -= d.amount;
  });
  timeUse[timeUse.length - 1].amount += total;
}
</script>

<code class=example>  // in drawChart…
  boundSelection<b>.transition()</b>.attr('d', generator).attr('fill', function (d,i) { return scale(i); });
</code>

<p>
Adding this method call does two things: it starts a clock ticking, and it returns a selection wrapped with transition-savvy replacements for all the usual <code>attr</code>/<code>property</code>/<code>style</code>/… operators plus some new ones which we'll see soon.
<p>
Instead of setting the elements' <var>d</var> and <var>fill</var> attributes to the provided values immediately, these operators now simply store the desired target state internally and return control to your code. In the background, the transition operator's clock (a <code>d3.timer()</code>, to be specific) is ready to fire at animation-rate intervals. On every tick, the transition's internal methods will update the respective DOM state to an <em>interpolated</em> value between its original and the target setting for that animation frame.

<h4>The basic idea of interpolation</h4>

<p>
Interpolation in D3 is actually very simple: the default interpolator simply looks looks for any number(s) in the current and target values and steps between them. There are a few simple ways to adjust how the animation progresses. A transitioning selection adds <code>.delay(<i>…</i>)</code> and <code>.duration(<i>…</i>)</code> operators which both take a millisecond value as their only parameter. There is also an <code>.ease(<i>…</i>)</code> parameter that allows customizing the animation timing curve, for example passing the shortcut string "cubic-in-out" will essentially "fade" the animation's speed as it starts and finishes.

<p>
The default interpolation works surprisingly well for a variety of situations: it can even do a servicable job of warping from one complete set of SVG path vertices to another, as we see in this pie chart example. If the default interpolation is not capable enough, you can actually pass customized interpolators to additional transition operators (<code>.attrTween()</code> and <code>.styleTween()</code> or even the raw <code>.tween()</code> operator. We'll dive deeper into this later in the chapter.


<h4>Deterministic transition transactions</h4>

<p>
Note that in all cases the target value is calculated immediately. That is, before the call to <code>.transition().<i>someOperator</i>(<i>someFunctionValue</i>)</code> returns, your <code>someFunctionValue</code> will have already been used to decide the target values for all elements. If the underlying data changes while the transition timer is causing redraw events, this will <em>not</em> effect what the user sees — unless of course you apply a replacement transition by e.g. calling our <code>drawChart()</code> code again. This case is really not much different; the new transition will animate the DOM from its current (potentially halfway through an earlier transition) to the (new) target state.

<p>
This is a good thing. It gives you full, deterministic control over what is drawn and when. You don't have to worry about subsequent user actions or data modification events sullying your careful calculations. You needn't worry about partial modifications or intermediate states your data may go through between calls to selection operators — any course correction to the animation in progress on screen happens whenever <em>you're</em> ready to apply it.


<h3>Object persistence with relational joins</h3>

<p>
TBD: this topic needs some coverage here, but might be better to save in-depth discussion for the interaction chapter where its inner workings are more relevant.

<h3>How relational joins work</h3>

<p>
Our chart is now correct after every update, but there's one potentially important piece we're missing. In our pie chart example so far, our data changes came in a relatively simple form, and due to the "update every relevant path property" nature of our drawing, we haven't actually missed it. So now that you have an aching longing in your heart for this missing knowlege…

<p>
TBD: as this especially derptastic introduction indicates…our pie chart is not really the best example to introduce this. Mike Bostock uses <a href="http://mbostock.github.io/d3/tutorial/bar-2.html">an example where elements get unshifted</a> from the front of a bar chart's array to better illustrate the need for what he terms "object constancy". However, the need for this may be even simpler to illustrate in another chapter.

TBD-plan: maybe the best way to approach this is with small multiples! subtly encapsulate the chart drawing and then do a carousel (or sortable) display where existing pie charts are continously shifted around

<!-- c.f. http://bost.ocks.org/mike/join/ and http://bost.ocks.org/mike/selection/ -->

<p>
… [using .data binding to associate existing DOM elements (usually via the data bound on them) with new versions of their data] …


<h3>Transition tips and tricks</h3>

<p>
TBD: when/how to use sort/order

<p>
TBD: dive into smoother entrance/exit example (i.e. appending before starting transition, how remove works after fading opacity)

<p>
TBD: handling subselections when modifying

<p>
TBD: dive deeper into staging sequential animations

<p>
TBD: discuss manual tweening

<p>
TBD: animation easing and such also easily merit its own expansion — might need a bit more detail above, however

<h3>Using CSS3/SVG alternatives to .transition()</h3>

<p>
TBD: make sure readers are aware of CSS3 transitions and SVG animation, which are potentially more efficient ways of transitioning data. Show at least one example of each, triggering the necessary stuff via D3 of course.


<!-- /TYPING -->


<h2>Interactive data displays</h2>


<script>

DATA = {};

DATA.timeUse = [
  {activity:"Field work", amount:50},
  {activity:"Choring animals", amount: 10},
  {activity:"Meal time", amount: 8},
  {activity:"Playing fiddle", amount: 2},
  {activity:"Resting", amount:30}
];

</script>
<script>
d3.selectAll('script[type="x-book/x-sample"]').select(function () {
  // show the container properly and reveal its soure if requested
  var container = this.previousElementSibling;
  container.classList.add('example');
  container.classList.add('output');
  if ('reveal' in container.dataset) {
      var el = document.createElement('code');
      delete container.dataset.reveal;
      el.textContent = container.outerHTML;
      el.classList.add('example');
      el.classList.add('source');
      this.parentNode.insertBefore(el, this);
  }
  
  // run the sample to show the result (within the node immediately preceding it)
  try {
    eval("(function ("+d3.keys(DATA).join(',')+") {" + this.textContent + "})")
      .apply(container, d3.values(DATA));
  } catch (e) { console.warn(e); }
  
  // display the code within a visible block
  var el = document.createElement('code');
  el.textContent = this.textContent.trim();
  if (!('hidden' in this.dataset)) this.parentNode.replaceChild(el, this)
  return el;
}).classed('example', true);
</script>
</body></html>

