<!doctype html>
<html><head>
    <meta charset="utf-8">
    <title>Chapter sample</title>
    <script src="d3.v3.min.js"></script>
    <style>
      body { max-width: 50em; }
      svg.example.output {
        display: block; background: #FBFBFB;
        margin: 2em 4em; padding: 1em;
        max-width: 20em;
        max-height: 20em;
      }
      code.example {
        display: block; background: #DDD;
        margin: 2em 5em; padding: 1em;
        white-space: pre;
        overflow: auto;
      }
    </style>
</head><body>

<h1>D3.js in Awesome</h1>

<h2>What is D3.js?</h2>
…
<h2>Showing data using SVG</h2>
…
<!--
(Finish with chart referenced in animation chapter)
<svg class="example output"></svg>
<script type="x-book/x-sample">
var layout = d3.layout.pie().value(function (d) { return d.amount; }),
    generator = d3.svg.arc().outerRadius(10),
    scale = d3.scale.category10();

// TODO: add labels, c.f. http://bl.ocks.org/enjalot/1203641

d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout)
  .enter().append('svg:path').attr('d', generator).attr('fill', function (d,i) { return scale(i); });
</script>
-->


<!-- TYPING -->

<h2>Animated transitions</h2>

<p>
We've turned all sorts of data into all sorts of charts.

<p>
These charts communicate well and look great, but are probably out of date within a few trillion CPU cycles…that's what, ten minutes in human years? The message you need convey may be constantly changing. Otherwise, if the underlying <em>data</em> doesn't change, why not let viewers change how it's <em>presented</em> to better understand the information?

<p>
In the next chapter we'll see how to add this user interaction, and in Chapter 6 we'll look at various ways your code can best manage the changing state of the data it's displaying.

<h3>Same old operators, brand new data</h3>

<p>
For now, though, let's continue focusing on what the viewer sees, the visible results.

<p>
Remember how we said D3.js makes it easy not just to create a data display, but to update an existing document with changed data? Let's take our pie chart from the last chapter. We've wrapped all the drawing code in a function, but it's otherwise identical:

<svg class="example output"></svg>
<script type="x-book/x-sample">
function drawChart() {
  var layout = d3.layout.pie().value(function (d) { return d.amount; }),
      generator = d3.svg.arc().outerRadius(10),
      scale = d3.scale.category10();
  
  d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout)
    .enter().append('svg:path').attr('d', generator).attr('fill', function (d,i) { return scale(i); });  
}
drawChart.call(this);
</script>

<p>
For each sample data item, we simply append the SVG element which will represent it visually and set its properties accordingly. This, however, doesn't support changing the visual representation when the data changes. If we change the data and run this code again, what will happen? D3 will join the changed data with the result of <code>.selectAll('path')</code>, which we said in Chapter 1 involves dividing the selection into its three sets: the entering set (missing elements), the updating set (elements already present), and exiting set (extra elements).

<p>
If we only handle the entering part of our selection, new elements will display as intended the first time but then will never change! This code will only work with <em>additional</em> data, not with revised or removed data. Of course, with something like a pie chart where the data all needs to fit within the same space each time, even that  Let's fix that.

<h3>Letting charts get lively</h3>

<p>
Here's how we need to write our <code>drawChart()</code> function so it works properly when called multiple times, regardless of how the data changes in between calls:

<svg class="example output"></svg>
<script type="x-book/x-sample">
function drawChart() {
  var layout = d3.layout.pie().value(function (d) { return d.amount; }),
      generator = d3.svg.arc().outerRadius(10),
      scale = d3.scale.category10();
  
  var boundSelection = d3.select(this).attr('viewBox',"-10 -10 20 20").datum(timeUse).selectAll('path').data(layout);
  boundSelection.enter().append('svg:path');
  // what we append/insert/select in the entering selection gets added to the main (updating) selection (from v2.0)
  boundSelection.attr('d', generator).attr('fill', function (d,i) { return scale(i); });
  boundSelection.exit().remove();
}

// generate the "original" DOM
drawChart.call(this);

// redraw changed data every 2.5 seconds
window.setInterval(function () {
  randomizeData();
  drawChart.call(this);
}.bind(this), 2500);


var originalLength = timeUse.length;      // used for toggling length
function randomizeData() {
  // modify the number of items
  if (timeUse.length === originalLength) timeUse.push({
    activity: "Gathering lumber"
  });
  else timeUse.pop();
  
  // "randomly" allocate percentages
  var total = 100;
  timeUse.forEach(function (d) {
    d.amount = total * Math.random() / 2;
    total -= d.amount;
  });
  timeUse[timeUse.length - 1].amount += total;
}
</script>

<p>
Here's what we had to do:

<ul>
<li>move the data-dependent operations from the enter to the *updating* selection</li>
<li>handle any data removal that might occur via the exiting selection</li>
</ul>

<p>
This achieves the immediate goal. Whenver the data changes we are able to update the DOM accordingly, and the viewer can always see the correct data.

<p>
Well…sort of. In practice, it's really hard to actually see which data changed and how. It just blinks!

<!--
c.f. http://vis.berkeley.edu/papers/animated_transitions/
http://bost.ocks.org/mike/path/
http://bl.ocks.org/mbostock/1098617
http://bl.ocks.org/mbostock/1346410
-->

<p>
[diagram of e.g. stick figure walking frames]

<p>
It would be much easier for our eyes to grasp what's happening if the visual change mimics a more physical change. To accomplish this, we will <em>animate</em> the change — we will cause the browser to rapidly display intermediate states of our visualization as if it were <em>transitioning</em> from the original to the modified presentation.
<p>
To the eye, this will communicate motion. This motion helps the viewer better comprehend the change; just as a visualization aids spatial interpretation of numeric <em>data</em>, animation adds a kinetic understanding of quantitative or qualitative <em>change</em>.
<p>
Animation has an aesthetic aspect, too, just as static visualization does. One academic study of "Animated Transitions in Statistical Data Graphics" (Heer 2007) concluded subjects "felt that [animation] facilitated both improved understanding and increased engagement." There were more scientific results to their study of course, but these feelings matter too. A chart can be beautiful; a transition can be <em>fun</em>!
<p>
As you might have come to expect, with D3 there is a succint but powerful way to animate a DOM change. Simply apply the <code>.transition()</code> operator to any selection to yield some very useful specialized behaviour:

<code class=example>
boundSelection<b>.transition()</b>.attr('d', generator).attr('fill', function (d,i) { return scale(i); });
</code>

<p>
Adding this method call does two things: it starts a clock ticking, and it returns a selection wrapped with transition-savvy replacements for all the usually <code>attr</code>/<code>property</code>/<code>style</code>/etc. (as well as providing some new ones, introduced soon).
<p>
Instead of setting the <var>d</var> and <var>fill</var> elements to the provided values immediately, these operators now simply store the desired target state internally and return immediately. In the background, the transition operator's clock (a <code>d3.timer()</code>, to be specific) is ticking at animation-rate intervals. On every tick, the transitions internal methods update the respective DOM state to an <em>interpolated</em> value between its original and the target setting.
<p>
Interpolation in D3 is actually very simple: the default interpolator simply looks looks for any number(s) in the current and target values and steps between them. There are a few simple ways to adjust how the animation progresses. A transitioning selection adds <code>.delay(<i>…</i>)</code> and <code>.duration(<i>…</i>)</code> operators which both take a millisecond value as their only parameter. There is also an <code>.ease(<i>…</i>)</code> parameter that allows customizing the animation timing curve, for example passing the shortcut string "cubic-in-out" will essentially "fade" the animation's speed as it starts and finishes.
<p>
The default interpolation works surprisingly well for a variety of situations: it can even do a servicable job of warping from one complete set of SVG path vertices to another, as we see in this pie chart example. If the default interpolation is not sophisticated enough, you can actually pass customized interpolators to additional transition operators (<code>.attrTween()</code> and <code>.styleTween()</code> or even the raw <code>.tween()</code> operator. We'll dive deeper into this later in this chapter.

<p>
TBD: animation easing and such also easily merit its own expansion  — but might be better to defer this discussion until later in the chapter too
<p>
Note that in all cases the target value is calculated immediately. That is, before the call to <code>.transition().<i>someOperator</i>(<i>someFunctionValue</i>)</code> returns, your <code>someFunctionValue</code> will have already been used to decide the target values for all elements. If the underlying data changes while the transition timer is causing redraw events, this will <em>not</em> effect what the user sees — unless of course you apply a replacement transition by e.g. calling our <code>drawChart()</code> code again. This case is really not much different; the new transition will animate the DOM from its current (potentially halfway through an earlier transition) to the (new) target state.

<h3>Object persistence with relational joins</h3>

<pre>
example above: items still changing color, etc.
</pre>

<h3>How relational joins work</h3>
<h3>Transition tips and tricks</h3>
<h3>Using CSS3/SVG alternatives to .transition()</h3>


<!-- /TYPING -->


<h2>Interactive data displays</h2>


<script>

DATA = {};

DATA.timeUse = [
  {activity:"Field work", amount:50},
  {activity:"Choring animals", amount: 10},
  {activity:"Meal time", amount: 8},
  {activity:"Playing fiddle", amount: 2},
  {activity:"Resting", amount:30}
];

</script>
<script>
d3.selectAll('script[type="x-book/x-sample"]').select(function () {
  // run the sample to show the result (within the node immediately preceding it)
  try {
    eval("(function ("+d3.keys(DATA).join(',')+") {" + this.textContent + "})")
      .apply(this.previousElementSibling, d3.values(DATA));
  } catch (e) { console.warn(e); }
  
  // display the code within a visible block
  var el = document.createElement('code');
  el.textContent = this.textContent.trim();
  this.parentNode.replaceChild(el, this)
  return el;
}).classed('example', true);
</script>
</body></html>

